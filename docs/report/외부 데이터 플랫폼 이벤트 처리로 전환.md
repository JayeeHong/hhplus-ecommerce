## 외부 데이터 플랫폼 이벤트 처리로 전환

### 1. 목적
- 주문 및 결제 처리 시 (`orderFacade.orderPayment`) `orderService.paidOrder` 에서 외부 데이터 플랫폼에 주문 정보를 전송합니다.
- 만약 외부 데이터 플랫폼 전송(`orderExternalClient.sendOrderMessage`) 시 예외가 발생하게 되면 주문 및 결제 Tx에 영향을 끼치게 됩니다.
- 이를 방지하기 위해 주문 및 결제 처리 후 이벤트를 발행하여 외부 데이터 플랫폼에 주문 정보를 전송하고자 합니다.

---

### 2. AS-IS
- `orderService.paidOrder` 에서 외부 데이터 플랫폼으로 전송하는 메소드를 단순 호출하고 있습니다.
```java
    // OrderService.java
    @Transactional
    public void paidOrder(Long orderId) {
        Order order = orderRepository.findById(orderId);
        order.paid(LocalDateTime.now());

        orderExternalClient.sendOrderMessage(order);
    }

    // OrderExternalClient.java
    public interface OrderExternalClient {

        void sendOrderMessage(Order order);

    }

    // OrderExternalClientImpl.java
    @Slf4j
    @Component
    public class OrderExternalClientImpl implements OrderExternalClient {

        @Override
        public void sendOrderMessage(Order order) {
            log.info("외부 데이터 플랫폼 주문정보 저장 : {}", order);
        }
    }
```

---

### 3. TO-BE
- 외부 데이터 플랫폼에 주문 정보를 전송하는 이벤트를 등록합니다.
- 주문 및 결제 처리 시 해당 이벤트 리스너를 호출하여 외부 데이터 플랫폼에 주문 정보를 전송하도록 합니다.  

> 📌 이벤트 호출용 객체
```java
@Getter
public class OrderInfoEvent {

    private final Long orderId;
    private final Long userId;
    private final Long userCouponId;
    private final long totalPrice;
    private final long discountPrice;
    private final LocalDateTime paidAt;
    private final List<OrderInfoItemEvent> orderItems;

    public OrderInfoEvent(Order order) {
        this.orderId = order.getId();
        this.userId = order.getUserId();
        this.userCouponId = order.getUserCouponId();
        this.totalPrice = order.getTotalPrice();
        this.discountPrice = order.getDiscountPrice();
        this.paidAt = order.getPaidAt();

        List<OrderInfoItemEvent> result = new ArrayList<>();
        for (OrderItem orderItem : order.getOrderItems()) {
            result.add(new OrderInfoItemEvent(orderItem));
        }

        this.orderItems = result;
    }

    public class OrderInfoItemEvent {

        private final Long productId;
        private final String productName;
        private final Long unitPrice;
        private final int quantity;

        public OrderInfoItemEvent(OrderItem item) {
            this.productId = item.getProductId();
            this.productName = item.getProductName();
            this.unitPrice = item.getUnitPrice();
            this.quantity = item.getQuantity();
        }

    }

} 
```

> 📌 이벤트 리스너
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class OrderInfoEventListener {

    private final OrderExternalClient orderExternalClient;

    @Async("orderEventExecutor")
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void orderSuccessHandler(Order order) {

        log.info("주문 정보 이벤트 발행");

        orderExternalClient.sendOrderMessage(order);
    }

}
```

> 📌 이벤트 퍼블리셔
```java
@Component
@RequiredArgsConstructor
public class OrderInfoEventPublisher {

    private final ApplicationEventPublisher applicationEventPublisher;

    public void success(Order order) {
        applicationEventPublisher.publishEvent(order);
    }

}
```

> 📌 `orderFacade.orderPayment` -> `orderService.paidOrder` 에서 외부 데이터 플랫폼에 전송하는 부분 수정
```java
    @Transactional
    public void paidOrder(Long orderId) {
        Order order = orderRepository.findById(orderId);
        order.paid(LocalDateTime.now());
        
        orderInfoEventPublisher.success(order);
    }
```

---

> **📜참고 1. Async 설정**  
> 1. `@EnableAsync가 필요한 이유`
>    1. 빈 후처리기 등록: `@EnableAsync`를 선언하면, Spring이 `AsyncAnnotaionBeanPostProcessor` 라는 빈 후처리기를 컨텍스트에 등록합니다.
>    2. 프록시 생성: 이 후처리기가 `@Async`가 붙은 메서드를 가진 빈을 찾아 AOP 프록시를 씌워 줍니다.
>    3. AOP 기반 비동기 호출: 프록시를 통해 메서드 호출이 들어오면, 실제 메서드 로직은 별도의 스레드에서 실행하도록 `TaskExecutor`에 위임하게 됩니다.
>    4. 효과: `@EnableAsync`가 없으면, @Async는 단순히 스프링이 모르는 애토네이션이 되고, 메서드가 동기적으로 바로 실행됩니다.
> 2. 커스텀 `Executor` 빈을 등록해야 하는 이유  
>    스프링은 `@Async`를 위해 내부적으로 `TaskExecutor`를 사용하는데, 
>    기본 설정에는 특별한 스레드풀 없이 매번 새 스레드를 생성하는 `SimpleAsyncTaskExecutor`를 사용합니다.  
>    이는 다음과 같은 문제를 일으킬 수 있습니다.
>    1. 무제한 스레드 생성:   
>    동시 호출이 많아지면 스레드가 계속 늘어나서 결국 과도한 컨텍스트 스위칭과 메모리 사용으로 애플리케이션 성능이 급락합니다.
>    2. 스레드 이름, 풀 크기 관리 불가:  
>    디버깅이나 모니터링 시, 어떤 작업이 어느 스레드에서 실행되었는지 구분하기 어렵습니다.
>    3. Queue-Backoff 전략 부재:  
>    스레드가 모두 바쁘면 대기열에 쌓고 적절히 거절하거나 지연(backoff)할 수 있어야 하는데, `SimpleAsyncTaskExecutor`는 이런 제어 기능이 없습니다.
```java
@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean(name = "orderEventExecutor")
    public Executor orderEventExecutor() {
        ThreadPoolTaskExecutor exec = new ThreadPoolTaskExecutor();
        exec.setCorePoolSize(2);
        exec.setMaxPoolSize(5);
        exec.setQueueCapacity(50);
        exec.setThreadNamePrefix("OrderEvent.");
        exec.initialize();
        return exec;
    }
}
```
- CorePoolSize / MaxPoolSize:  
  최소/최대 스레드 갯수를 설정해서 자원 과다 사용을 방지
- QueueCapacity:  
  최대 큐 길이를 정해 과도한 작업 폭증 시 거절 정책을 선택 가능
- ThreadNamePrefix:  
  로그, 스레드 덤프 분석 시 어떤 작업이 어느 풀의 스레드인지 명확하게 표기

---

> **📜참고 2. 예외 처리 및 재시도 전략**  
> 외부 플랫폼 호출이 실패했을 때,
> - `@Async`로 비동기 실행되더라도 기본적으로 재시도하지 않습니다.
> - 중요한 데이터라면 `Spring Retry 나 큐(예: Kafka, RabbitMQ) 기반 재시도 로직을 추가하는 것을 고려할 수 있을 것 같습니다.
> - 실패 메시지를 별도 Dead-Letter 큐로 보내고 운영자가 재처리할 수 있게 할 수도 있다고 합니다.
```java
@Async("orderEventExecutor")
@TransactionalEventListener(phase = AFTER_COMMIT)
@Retryable(
  value = { ExternalPlatformException.class },
  maxAttempts = 3,
  backoff = @Backoff(delay = 5000)
)
public void orderSuccessHandler(OrderInfoEvent evt) {
    orderExternalClient.sendOrderMessage(evt);
}
```