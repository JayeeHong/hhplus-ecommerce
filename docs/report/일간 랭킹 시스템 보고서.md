## 일간 랭킹 시스템 보고서

---

### 1. 개요

* **목적**:
  주문 및 결제가 이루어진 후, 주문한 상품의 일간 랭킹을 집계하여 서비스에 활용합니다.

---

### 2. 주요 고려사항

1. **캐싱 기준**
  * 주문한 상품의 개수를 기준으로 Redis에 캐싱

2. **시점 보장**
  * 주문과 결제 로직이 완전히 커밋된 후에만 캐싱

3. **트랜잭션 분리**
  * 캐싱 실패가 주문 트랜잭션에 영향을 주지 않아야 함
  * 캐싱 오류 발생 시 로그만 남기고 주문은 정상 처리

---

### 3. 아키텍처 및 흐름

```docs
 (주문완료)      ---------->      (캐싱 처리 이벤트 호출) 
 orderPayment            publisher.publishEvent(new ProductOrderedEvent..)
[OrderFacade]

--------> (랭킹 이벤트 리스너)
          RankingEventListener
```

1. **OrderFacade**
  * 주문 결제 완료 후 `ProductOrderedEvent` 발행

2. **RankingEventListener**
  * `@TransactionalEventListener(phase = AFTER_COMMIT)`로 커밋 후 이벤트 수신
  * Redis Sorted Set에 점수(수량) 누적

3. **DailyRankScheduler**
  * 매일 00:05에 실행 (`cron = "0 5 0 * * *"`)
  * 전날 기준 키(`daily:ranking:{YYYY-MM-DD}`)로 레디스 조회 후 RDB에 적재

---

### 4. 캐싱 이벤트 클래스

```java
@Getter
public class ProductOrderedEvent {
    private final List<ProductInfo.OrderItem> items;   // 주문 상품 목록
    private final LocalDate         orderDate;        // 주문 날짜 (score 기준)

    public ProductOrderedEvent(List<ProductInfo.OrderItem> items, LocalDate orderDate) {
        this.items     = items;
        this.orderDate = orderDate;
    }
}
```

---

### 5. 랭킹 이벤트 리스너

```java
@Component
@RequiredArgsConstructor
@Slf4j
public class RankingEventListener {
    private final RankCacheRepository cacheRepository;

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handle(ProductOrderedEvent event) {
        String key = "daily:ranking:" + event.getOrderDate();
        log.info("Daily ranking key: {}", key);

        for (ProductInfo.OrderItem item : event.getItems()) {
            try {
                cacheRepository.incrementScore(
                  key,
                  item.getProductId().toString(),
                  item.getQuantity()
                );
            } catch (Exception e) {
                // 캐싱 실패 시에도 주문 트랜잭션에 영향 없음
                log.error("Redis ranking cache failed for key={}, member={}",
                          key, item.getProductId(), e);
            }
        }
    }
}
```

---

### 6. Redis 캐시 레포지토리

```java
public interface RankCacheRepository {
    void incrementScore(String dateKey, String member, double delta);
    Set<ZSetOperations.TypedTuple<String>> getSortedSet(String dateKey);
    void deleteKey(String dateKey);
}

@Component
public class RedisDailyRankCacheRepository implements RankCacheRepository {
    private final RedisTemplate<String, String> redis;
    private final ZSetOperations<String, String>  zset;
    private static final Duration CACHE_TTL = Duration.ofHours(25);

    public RedisDailyRankCacheRepository(RedisTemplate<String, String> redis) {
        this.redis = redis;
        this.zset  = redis.opsForZSet();
    }

    @Override
    public void incrementScore(String dateKey, String member, double delta) {
        zset.incrementScore(dateKey, member, delta);
        redis.expire(dateKey, CACHE_TTL);
    }

    @Override
    public Set<TypedTuple<String>> getSortedSet(String dateKey) {
        return zset.reverseRangeWithScores(dateKey, 0, -1);
    }

    @Override
    public void deleteKey(String dateKey) {
        redis.delete(dateKey);
    }
}
```

---

### 7. 일별 랭킹 스케줄러

```java
@Component
@RequiredArgsConstructor
@Slf4j
public class DailyRankScheduler {
    private final RankCacheRepository       rankCacheRepository;
    private final DailyProductRankRepository dailyProductRankRepository;

    // 매일 00:05에 어제 랭킹 집계 실행
    @Scheduled(cron = "0 5 0 * * *")
    public void flushDailyRanking() {
        LocalDate yesterday = LocalDate.now(ZoneId.of("Asia/Seoul")).minusDays(1);
        String key = "daily:ranking:" + yesterday;
        log.info("Daily ranking scheduler key: {}", key);

        Set<ZSetOperations.TypedTuple<String>> entries =
            rankCacheRepository.getSortedSet(key);
        if (entries == null || entries.isEmpty()) {
            return;
        }

        List<DailyProductRank> batch = entries.stream()
            .map(t -> DailyProductRank.builder()
                .rankDate(yesterday)
                .productId(Long.valueOf(t.getValue()))
                .score(t.getScore().longValue())
                .build()
            )
            .toList();

        dailyProductRankRepository.saveAll(batch);
    }
}
```

---

### 8. 결론

* **레디스를 사용한 이유**

  * **고성능 인메모리 처리**: 메모리 기반으로 초저지연 응답 가능
  * **Sorted Set 제공**: 점수 기반 자동 정렬로 순위 집계 로직 단순화
  * **TTL로 유효 기간 관리**: 매일 자동 만료로 별도 데이터 삭제 불필요

* **장점**

  * **실시간성**: 메모리 처리로 대량 요청에도 빠른 응답
  * **단순 구현**: ZINCRBY, ZREVRANGE 명령만으로 순위 갱신·조회 가능
  * **자동 만료**: TTL 설정으로 데이터 라이프사이클 자동 관리

* **단점**

  * **내구성 이슈**: AOF/RDB 스냅샷 설정에 따른 데이터 유실 가능성
  * **비용 부담**: 대용량 랭킹 보관 시 메모리 리소스·비용 증가
  * **운영 복잡도**: 클러스터 설정, 모니터링, 페일오버 등 운영 부담 증가
