## 선착순 쿠폰 발급 시스템 보고서

---

### 1. 개요

* **목적**:
  정해진 수량만큼 사용자에게 쿠폰을 발급한다. 

---

### 2. 아키텍처 및 흐름
```docs
     (사용자 쿠폰 발급)       -------------->            (레디스 선착순 쿠폰 발급)
UserCouponFacade.issueUserCoupon                  userCouponService.createUserCouponRedis

-----> (쿠폰 발급 RDB 처리)
userCouponService.createUserCoupon
```
- 레디스의 SortedSet 자료구조를 사용합니다.
  - key: usercoupon:issued:{couponId} 
  - score: 발급시간
  - value: timestamp
- RDB에 쿠폰 저장 전 레디스를 통해 정해진 수량 안에서 발급할 수 있는지 확인합니다.
```java
    private static final String ISSUED_KEY_PREFIX = "usercoupon:issued:";

    // 사용자 쿠폰 발행 - 레디스
    public void createUserCouponRedis(UserCouponCommand.Publish command) {
        String key = ISSUED_KEY_PREFIX + command.getCouponId();
        double score = System.currentTimeMillis();

        // 이미 발급된 사용자인지 확인
        Boolean alreadyIssued = redisTemplate.opsForZSet().score(key, String.valueOf(command.getUserId())) != null;
        if (Boolean.TRUE.equals(alreadyIssued)) {
            log.info("이미 사용자에게 발급된 쿠폰입니다. couponId={}, userId={}", command.getCouponId(),
                command.getUserId());
            throw new IllegalStateException("이미 사용자에게 발급된 쿠폰입니다.");
        }

        // 레디스 sorted set에 (userId, timestamp) 추가
        redisTemplate.opsForZSet().add(key, String.valueOf(command.getUserId()), score);

        // 순위 확인
        Long rank = redisTemplate.opsForZSet().rank(key, String.valueOf(command.getUserId()));
        if (rank == null || rank >= limit) {
            // N명 이후라면 방금 추가한 엔트리 제거 후 에러
            redisTemplate.opsForZSet().remove(key, String.valueOf(command.getUserId()));
            log.info("선착순 발급 수량 초과");
            throw new IllegalStateException("선착순 발급 수량 초과");
        }

        // 쿠폰의 만료일에 맞춰 TTL 지정
        redisTemplate.expireAt(key, Date.from(
            couponRepository.findById(command.getCouponId()).getExpiredAt()
                .atZone(ZoneId.of("Asia/Seoul")).toInstant()
        ));
    }
```
- TTL은 쿠폰에 설정한 만료시간으로 지정합니다. RDB 처리 시 실패한다면 해당 캐시는 만료시킵니다.
```java
    private static final String ISSUED_KEY_PREFIX = "usercoupon:issued:";

    // 사용자 쿠폰을 발행한다
    public UserCouponInfo.Coupon createUserCoupon(UserCouponCommand.Publish command) {
        String key = ISSUED_KEY_PREFIX + command.getCouponId();

        try {
            UserCoupon findCoupon = userCouponRepository.findByUserIdAndCouponId(
                command.getUserId(),
                command.getCouponId());

            if (findCoupon != null) {
                throw new IllegalArgumentException("이미 발급된 쿠폰입니다.");
            }

            UserCoupon userCoupon = UserCoupon.create(command.getUserId(), command.getCouponId());
            userCouponRepository.save(userCoupon);

            return UserCouponInfo.Coupon.toUserCouponInfo(userCoupon);
        } catch (RuntimeException e) {
            // DB 저장 실패 시 레디스 예약도 취소
            redisTemplate.opsForZSet().remove(key, String.valueOf(command.getUserId()));
            throw e;
        }
    }
```

---

### 4. 레디스 자료 구조 중 SortedSet 선택 이유
Redis의 **Sorted Set**을 선착순(First-Come-First-Served) 쿠폰 발급 시스템에 사용하는 주요 이유는 다음과 같습니다.

---

#### 1. 발급 순서 보장 및 조회 용이성

* **타임스탬프 기반 정렬**

  * 각 사용자를 `score` 값(예: 밀리초 단위 타임스탬프)으로 넣으면, 삽입 시점 순서 그대로 자동 정렬됩니다.
* **순위(순서) 조회**

  * `ZRANK`나 `ZRANGE` 커맨드로 “가장 먼저 발급받은 N명”을 빠르게 조회할 수 있습니다.
* **구간별 조회**

  * 예: 상위 100명만 혜택 제공 → `ZRANGE key 0 99` 한 줄로 처리 가능

---

#### 2. 원자적(Atomic) 업데이트 지원

* **ZADD의 원자성**
  * 여러 클라이언트가 동시 요청하더라도 내부적으로 락 없이 안전하게 삽입·업데이트됩니다.

* **경쟁 조건(Race Condition) 최소화**
  * 동시성 높은 환경에서도 정확한 순서 기록과 중복 방지가 가능합니다.

---

#### 3. 효율적인 메모리 사용 및 성능

* **O(log N) 삽입/삭제**
  * 대량의 발급 요청에도 로그 시간 복잡도로 빠르게 처리

* **인메모리 처리**
  * 디스크 I/O 없이 밀리초 단위 반응 속도 제공

* **TTL 관리**
  * `EXPIRE`를 함께 사용해 쿠폰 발급 기간이 지나면 자동으로 키 삭제

---

#### 4. 중복 발급 방지

* **멤버 유일성**
  * 동일한 사용자 ID가 다시 `ZADD` 되면 score만 갱신되므로, 삽입 여부로 중복 체크 가능
  * 기존 발급 사용자는 다시 삽입되지 않도록 로직 단순화

---

#### 5. 확장성 및 운영 편의

* **클러스터링 지원**
  * Redis Cluster로 수평 확장해 트래픽 급증에도 대응

* **모니터링·관리 툴 연동**
  * Redis Insight 등으로 Sorted Set 크기, 메모리 사용량, 주요 키 조회·삭제가 용이

---