## 병목이 예상 쿼리 보고서
### 병목 처리 전략
| 전략     | 설명 |
|--------|----|
| 집계 테이블 운영 | 인기 상품 집계 결과를 별도 테이블에 유지   |
| 배치 처리 | 조회가 잦은 데이터는 일정 주기로 정리/요약 |
| FOR UPDATE | 동시 접근 row를 락으로 보호 (비관적 락) |
| 낙관적 락 (@Version) | 변경 시점에만 충돌 체크 |
| Redis 캐시 | 재고/쿠폰/잔액 등 빠른 판단이 필요한 항목 캐싱 |

### 병목이 예상되는 상황
#### 1. 인기 상품 조회 (COUNT + GROUP BY)
```sql
SELECT product_id, COUNT(*)
FROM order_item
WHERE created_at >= NOW() - INTERVAL 3 DAY
GROUP BY product_id
ORDER BY COUNT(*) DESC
LIMIT 5;
```
- 문제: `order_item` 테이블이 수십만 건 이상이면 집계 성능 저하
- 해결
  - 조회 성능을 위해 별도 집계 테이블 (e.g. ProductSalesStats) 운영 + 주문 시 업데이트
  - 또는 배치 작업/스케줄러로 3일간 집계하여 별도 캐시 저장

#### 2. 잔액 차감 (Concurrent Deduct)
```sql
UPDATE balance
SET amount = amount - 1000
WHERE user_id = 1 AND amount >= 1000;
```
- 문제: 2개의 주문이 동시에 처리되면 잔액이 마이너스 가능
- 해결: `FOR UPDATE`로 row-level locking
  ```sql
  -- 트랜잭션 시작
  START TRANSACTION;
  
  -- 사용자 잔액 row 락
  SELECT amount FROM balance WHERE user_id = 1 FOR UPDATE;
  
  -- 잔액 검증 및 차감
  UPDATE balance SET amount = amount - 9000 WHERE user_id = 1;
  
  -- 트랜잭션 커밋
  COMMIT;
  ```

#### 3. 재고 감소 (Overselling)
```sql
UPDATE product
SET stock = stock - 1
WHERE id = 100 AND stock >= 1;
```
- 문제: 동시 실행 시 stock이 음수로 떨어질 수 있음
- 해결: SELECT … FOR UPDATE 또는 Redis 선처리 후 DB 반영

#### 4. 쿠폰 선착순 발급
```sql
UPDATE coupon
SET stock = stock - 1
WHERE id = 200 AND remain_count > 0;
```
- 문제: 초당 수천 건 요청 시 초과 발급 가능
- 해결: Redis + Lua 스크립트 기반으로 원자 처리 → DB에는 최종 상태만 반영

